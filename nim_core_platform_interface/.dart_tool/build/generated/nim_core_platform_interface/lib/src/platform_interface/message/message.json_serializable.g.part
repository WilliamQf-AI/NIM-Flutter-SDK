// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

NIMMessage _$NIMMessageFromJson(Map<String, dynamic> json) {
  return NIMMessage(
    messageId: json['messageId'] as int? ?? -1,
    sessionId: json['sessionId'] as String?,
    sessionType: _$enumDecodeNullable(
        _$NIMSessionTypeEnumMap, json['sessionType'],
        unknownValue: NIMSessionType.p2p),
    messageType: _$enumDecode(_$NIMMessageTypeEnumMap, json['messageType'],
        unknownValue: NIMMessageType.undef),
    messageSubType: _$enumDecodeNullable(
        _$NIMMessageTypeEnumMap, json['messageSubType'],
        unknownValue: NIMMessageType.undef),
    status: _$enumDecodeNullable(_$NIMMessageStatusEnumMap, json['status'],
        unknownValue: NIMMessageStatus.sending),
    messageDirection: _$enumDecode(
        _$NIMMessageDirectionEnumMap, json['messageDirection'],
        unknownValue: NIMMessageDirection.outgoing),
    fromAccount: json['fromAccount'] as String?,
    content: json['content'] as String?,
    timestamp: json['timestamp'] as int,
    messageAttachment:
        NIMMessageAttachment._fromMap(json['messageAttachment'] as Map?),
    attachmentDownloadState: _$enumDecodeNullable(
        _$NIMMessageAttachmentDownloadStateEnumMap,
        json['attachmentDownloadState'],
        unknownValue: NIMMessageAttachmentDownloadState.needDownload),
    uuid: json['uuid'] as String?,
    serverId: json['serverId'] as int?,
    config: NIMCustomMessageConfig._fromMap(json['config'] as Map?),
    remoteExtension: json['remoteExtension'] as Map<String, dynamic>?,
    localExtension: json['localExtension'] as Map<String, dynamic>?,
    callbackExtension: json['callbackExtension'] as String?,
    pushPayload: json['pushPayload'] as Map<String, dynamic>?,
    pushContent: json['pushContent'] as String?,
    memberPushOption:
        NIMMemberPushOption._fromMap(json['memberPushOption'] as Map?),
    senderClientType: _$enumDecodeNullable(
        _$NIMClientTypeEnumMap, json['senderClientType'],
        unknownValue: NIMClientType.unknown),
    antiSpamOption: NIMAntiSpamOption._fromMap(json['antiSpamOption'] as Map?),
    messageAck: json['messageAck'] as bool? ?? false,
    hasSendAck: json['hasSendAck'] as bool? ?? false,
    ackCount: json['ackCount'] as int? ?? 0,
    unAckCount: json['unAckCount'] as int? ?? 0,
    clientAntiSpam: json['clientAntiSpam'] as bool? ?? false,
    isInBlackList: json['isInBlackList'] as bool? ?? false,
    isChecked: json['isChecked'] as bool? ?? false,
    sessionUpdate: json['sessionUpdate'] as bool? ?? true,
    messageThreadOption:
        NIMMessageThreadOption._fromMap(json['messageThreadOption'] as Map?),
    quickCommentUpdateTime: json['quickCommentUpdateTime'] as int?,
    isDeleted: json['isDeleted'] as bool? ?? false,
    yidunAntiCheating: json['yidunAntiCheating'] as String?,
    env: json['env'] as String?,
    fromNickname: json['fromNickname'] as String?,
    isRemoteRead: json['isRemoteRead'] as bool?,
  );
}

Map<String, dynamic> _$NIMMessageToJson(NIMMessage instance) =>
    <String, dynamic>{
      'messageId': instance.messageId,
      'sessionId': instance.sessionId,
      'sessionType': _$NIMSessionTypeEnumMap[instance.sessionType],
      'messageType': _$NIMMessageTypeEnumMap[instance.messageType],
      'messageSubType': _$NIMMessageTypeEnumMap[instance.messageSubType],
      'status': _$NIMMessageStatusEnumMap[instance.status],
      'messageDirection':
          _$NIMMessageDirectionEnumMap[instance.messageDirection],
      'fromAccount': instance.fromAccount,
      'content': instance.content,
      'timestamp': instance.timestamp,
      'messageAttachment':
          NIMMessageAttachment._toMap(instance.messageAttachment),
      'attachmentDownloadState': _$NIMMessageAttachmentDownloadStateEnumMap[
          instance.attachmentDownloadState],
      'uuid': instance.uuid,
      'serverId': instance.serverId,
      'config': NIMCustomMessageConfig._toMap(instance.config),
      'remoteExtension': instance.remoteExtension,
      'localExtension': instance.localExtension,
      'callbackExtension': instance.callbackExtension,
      'pushPayload': instance.pushPayload,
      'pushContent': instance.pushContent,
      'memberPushOption': NIMMemberPushOption._toMap(instance.memberPushOption),
      'senderClientType': _$NIMClientTypeEnumMap[instance.senderClientType],
      'antiSpamOption': NIMAntiSpamOption._toMap(instance.antiSpamOption),
      'messageAck': instance.messageAck,
      'hasSendAck': instance.hasSendAck,
      'ackCount': instance.ackCount,
      'unAckCount': instance.unAckCount,
      'clientAntiSpam': instance.clientAntiSpam,
      'isInBlackList': instance.isInBlackList,
      'isChecked': instance.isChecked,
      'sessionUpdate': instance.sessionUpdate,
      'messageThreadOption':
          NIMMessageThreadOption._toMap(instance.messageThreadOption),
      'quickCommentUpdateTime': instance.quickCommentUpdateTime,
      'isDeleted': instance.isDeleted,
      'yidunAntiCheating': instance.yidunAntiCheating,
      'env': instance.env,
      'fromNickname': instance.fromNickname,
      'isRemoteRead': instance.isRemoteRead,
    };

K _$enumDecode<K, V>(
  Map<K, V> enumValues,
  Object? source, {
  K? unknownValue,
}) {
  if (source == null) {
    throw ArgumentError(
      'A value must be provided. Supported values: '
      '${enumValues.values.join(', ')}',
    );
  }

  return enumValues.entries.singleWhere(
    (e) => e.value == source,
    orElse: () {
      if (unknownValue == null) {
        throw ArgumentError(
          '`$source` is not one of the supported values: '
          '${enumValues.values.join(', ')}',
        );
      }
      return MapEntry(unknownValue, enumValues.values.first);
    },
  ).key;
}

K? _$enumDecodeNullable<K, V>(
  Map<K, V> enumValues,
  dynamic source, {
  K? unknownValue,
}) {
  if (source == null) {
    return null;
  }
  return _$enumDecode<K, V>(enumValues, source, unknownValue: unknownValue);
}

const _$NIMSessionTypeEnumMap = {
  NIMSessionType.none: 'none',
  NIMSessionType.p2p: 'p2p',
  NIMSessionType.team: 'team',
  NIMSessionType.superTeam: 'superTeam',
  NIMSessionType.system: 'system',
  NIMSessionType.ysf: 'ysf',
  NIMSessionType.chatRoom: 'chatRoom',
};

const _$NIMMessageTypeEnumMap = {
  NIMMessageType.undef: 'undef',
  NIMMessageType.text: 'text',
  NIMMessageType.image: 'image',
  NIMMessageType.audio: 'audio',
  NIMMessageType.video: 'video',
  NIMMessageType.location: 'location',
  NIMMessageType.file: 'file',
  NIMMessageType.avchat: 'avchat',
  NIMMessageType.notification: 'notification',
  NIMMessageType.tip: 'tip',
  NIMMessageType.robot: 'robot',
  NIMMessageType.netcall: 'netcall',
  NIMMessageType.custom: 'custom',
  NIMMessageType.appCustom: 'appCustom',
  NIMMessageType.qiyuCustom: 'qiyuCustom',
};

const _$NIMMessageStatusEnumMap = {
  NIMMessageStatus.draft: 'draft',
  NIMMessageStatus.sending: 'sending',
  NIMMessageStatus.success: 'success',
  NIMMessageStatus.fail: 'fail',
  NIMMessageStatus.read: 'read',
  NIMMessageStatus.unread: 'unread',
};

const _$NIMMessageDirectionEnumMap = {
  NIMMessageDirection.outgoing: 'outgoing',
  NIMMessageDirection.received: 'received',
};

const _$NIMMessageAttachmentDownloadStateEnumMap = {
  NIMMessageAttachmentDownloadState.needDownload: 'needDownload',
  NIMMessageAttachmentDownloadState.failed: 'failed',
  NIMMessageAttachmentDownloadState.downloading: 'downloading',
  NIMMessageAttachmentDownloadState.downloaded: 'downloaded',
  NIMMessageAttachmentDownloadState.cancel: 'cancel',
};

const _$NIMClientTypeEnumMap = {
  NIMClientType.unknown: 'unknown',
  NIMClientType.android: 'android',
  NIMClientType.ios: 'ios',
  NIMClientType.windows: 'windows',
  NIMClientType.wp: 'wp',
  NIMClientType.web: 'web',
  NIMClientType.rest: 'rest',
  NIMClientType.macos: 'macos',
};

NIMCustomMessageConfig _$NIMCustomMessageConfigFromJson(
    Map<String, dynamic> json) {
  return NIMCustomMessageConfig(
    enableHistory: json['enableHistory'] as bool,
    enableRoaming: json['enableRoaming'] as bool,
    enableSelfSync: json['enableSelfSync'] as bool,
    enablePush: json['enablePush'] as bool,
    enablePushNick: json['enablePushNick'] as bool,
    enableUnreadCount: json['enableUnreadCount'] as bool,
    enableRoute: json['enableRoute'] as bool,
    enablePersist: json['enablePersist'] as bool,
  );
}

Map<String, dynamic> _$NIMCustomMessageConfigToJson(
        NIMCustomMessageConfig instance) =>
    <String, dynamic>{
      'enableHistory': instance.enableHistory,
      'enableRoaming': instance.enableRoaming,
      'enableSelfSync': instance.enableSelfSync,
      'enablePush': instance.enablePush,
      'enablePushNick': instance.enablePushNick,
      'enableUnreadCount': instance.enableUnreadCount,
      'enableRoute': instance.enableRoute,
      'enablePersist': instance.enablePersist,
    };

NIMFileAttachment _$NIMFileAttachmentFromJson(Map<String, dynamic> json) {
  return NIMFileAttachment(
    path: json['path'] as String?,
    size: json['size'] as int?,
    md5: json['md5'] as String?,
    url: json['url'] as String?,
    displayName: json['name'] as String?,
    extension: json['ext'] as String?,
    expire: json['expire'] as int?,
    nosScene: _$enumDecodeNullable(_$NIMNosSceneEnumMap, json['sen'],
            unknownValue: NIMNosScene.defaultIm) ??
        NIMNosScene.defaultIm,
    forceUpload: json['force_upload'] as bool,
  );
}

Map<String, dynamic> _$NIMFileAttachmentToJson(NIMFileAttachment instance) =>
    <String, dynamic>{
      'path': instance.path,
      'url': instance.url,
      'size': instance.size,
      'md5': instance.md5,
      'name': instance.displayName,
      'ext': instance.extension,
      'expire': instance.expire,
      'sen': _$NIMNosSceneEnumMap[instance.nosScene],
      'force_upload': instance.forceUpload,
    };

const _$NIMNosSceneEnumMap = {
  NIMNosScene.defaultProfile: 'defaultProfile',
  NIMNosScene.defaultIm: 'defaultIm',
  NIMNosScene.systemNosScene: 'systemNosScene',
  NIMNosScene.securityPrefix: 'securityPrefix',
};

NIMAudioAttachment _$NIMAudioAttachmentFromJson(Map<String, dynamic> json) {
  return NIMAudioAttachment(
    duration: json['dur'] as int?,
    autoTransform: json['autoTransform'] as bool?,
    text: json['text'] as String?,
    path: json['path'] as String?,
    size: json['size'] as int?,
    md5: json['md5'] as String?,
    url: json['url'] as String?,
    displayName: json['name'] as String?,
    extension: json['ext'] as String?,
    expire: json['expire'] as int?,
    nosScene: _$enumDecodeNullable(_$NIMNosSceneEnumMap, json['sen'],
            unknownValue: NIMNosScene.defaultIm) ??
        NIMNosScene.defaultIm,
    forceUpload: json['force_upload'] as bool,
  );
}

Map<String, dynamic> _$NIMAudioAttachmentToJson(NIMAudioAttachment instance) =>
    <String, dynamic>{
      'path': instance.path,
      'url': instance.url,
      'size': instance.size,
      'md5': instance.md5,
      'name': instance.displayName,
      'ext': instance.extension,
      'expire': instance.expire,
      'sen': _$NIMNosSceneEnumMap[instance.nosScene],
      'force_upload': instance.forceUpload,
      'dur': instance.duration,
      'autoTransform': instance.autoTransform,
      'text': instance.text,
    };

NIMVideoAttachment _$NIMVideoAttachmentFromJson(Map<String, dynamic> json) {
  return NIMVideoAttachment(
    duration: json['dur'] as int?,
    width: json['w'] as int?,
    height: json['h'] as int?,
    thumbPath: json['thumbPath'] as String?,
    thumbUrl: json['thumbUrl'] as String?,
    path: json['path'] as String?,
    size: json['size'] as int?,
    md5: json['md5'] as String?,
    url: json['url'] as String?,
    displayName: json['name'] as String?,
    extension: json['ext'] as String?,
    expire: json['expire'] as int?,
    nosScene: _$enumDecodeNullable(_$NIMNosSceneEnumMap, json['sen'],
            unknownValue: NIMNosScene.defaultIm) ??
        NIMNosScene.defaultIm,
    forceUpload: json['force_upload'] as bool,
  );
}

Map<String, dynamic> _$NIMVideoAttachmentToJson(NIMVideoAttachment instance) =>
    <String, dynamic>{
      'path': instance.path,
      'url': instance.url,
      'size': instance.size,
      'md5': instance.md5,
      'name': instance.displayName,
      'ext': instance.extension,
      'expire': instance.expire,
      'sen': _$NIMNosSceneEnumMap[instance.nosScene],
      'force_upload': instance.forceUpload,
      'dur': instance.duration,
      'w': instance.width,
      'h': instance.height,
      'thumbPath': instance.thumbPath,
      'thumbUrl': instance.thumbUrl,
    };

NIMImageAttachment _$NIMImageAttachmentFromJson(Map<String, dynamic> json) {
  return NIMImageAttachment(
    thumbPath: json['thumbPath'] as String?,
    thumbUrl: json['thumbUrl'] as String?,
    width: json['w'] as int?,
    height: json['h'] as int?,
    path: json['path'] as String?,
    size: json['size'] as int?,
    md5: json['md5'] as String?,
    url: json['url'] as String?,
    displayName: json['name'] as String?,
    extension: json['ext'] as String?,
    expire: json['expire'] as int?,
    nosScene: _$enumDecodeNullable(_$NIMNosSceneEnumMap, json['sen'],
            unknownValue: NIMNosScene.defaultIm) ??
        NIMNosScene.defaultIm,
    forceUpload: json['force_upload'] as bool,
  );
}

Map<String, dynamic> _$NIMImageAttachmentToJson(NIMImageAttachment instance) =>
    <String, dynamic>{
      'path': instance.path,
      'url': instance.url,
      'size': instance.size,
      'md5': instance.md5,
      'name': instance.displayName,
      'ext': instance.extension,
      'expire': instance.expire,
      'sen': _$NIMNosSceneEnumMap[instance.nosScene],
      'force_upload': instance.forceUpload,
      'thumbPath': instance.thumbPath,
      'thumbUrl': instance.thumbUrl,
      'w': instance.width,
      'h': instance.height,
    };

NIMLocationAttachment _$NIMLocationAttachmentFromJson(
    Map<String, dynamic> json) {
  return NIMLocationAttachment(
    latitude: (json['lat'] as num).toDouble(),
    longitude: (json['lng'] as num).toDouble(),
    address: json['title'] as String,
  );
}

Map<String, dynamic> _$NIMLocationAttachmentToJson(
        NIMLocationAttachment instance) =>
    <String, dynamic>{
      'lat': instance.latitude,
      'lng': instance.longitude,
      'title': instance.address,
    };

NIMMessageReceipt _$NIMMessageReceiptFromJson(Map<String, dynamic> json) {
  return NIMMessageReceipt(
    sessionId: json['sessionId'] as String,
    time: json['time'] as int,
  );
}

Map<String, dynamic> _$NIMMessageReceiptToJson(NIMMessageReceipt instance) =>
    <String, dynamic>{
      'sessionId': instance.sessionId,
      'time': instance.time,
    };

NIMAntiSpamOption _$NIMAntiSpamOptionFromJson(Map<String, dynamic> json) {
  return NIMAntiSpamOption(
    enable: json['enable'] as bool,
    content: json['content'] as String,
    antiSpamConfigId: json['antiSpamConfigId'] as String?,
  );
}

Map<String, dynamic> _$NIMAntiSpamOptionToJson(NIMAntiSpamOption instance) =>
    <String, dynamic>{
      'enable': instance.enable,
      'content': instance.content,
      'antiSpamConfigId': instance.antiSpamConfigId,
    };

NIMMemberPushOption _$NIMMemberPushOptionFromJson(Map<String, dynamic> json) {
  return NIMMemberPushOption(
    forcePushContent: json['forcePushContent'] as String?,
    forcePushList: (json['forcePushList'] as List<dynamic>?)
        ?.map((e) => e as String)
        .toList(),
    isForcePush: json['isForcePush'] as bool? ?? true,
  );
}

Map<String, dynamic> _$NIMMemberPushOptionToJson(
        NIMMemberPushOption instance) =>
    <String, dynamic>{
      'forcePushList': instance.forcePushList,
      'forcePushContent': instance.forcePushContent,
      'isForcePush': instance.isForcePush,
    };

NIMMessageThreadOption _$NIMMessageThreadOptionFromJson(
    Map<String, dynamic> json) {
  return NIMMessageThreadOption(
    replyMessageFromAccount: json['replyMessageFromAccount'] as String,
    replyMessageIdClient: json['replyMessageIdClient'] as String,
    replyMessageIdServer: json['replyMessageIdServer'] as int?,
    replyMessageTime: json['replyMessageTime'] as int?,
    replyMessageToAccount: json['replyMessageToAccount'] as String,
    threadMessageFromAccount: json['threadMessageFromAccount'] as String,
    threadMessageIdClient: json['threadMessageIdClient'] as String,
    threadMessageIdServer: json['threadMessageIdServer'] as int?,
    threadMessageTime: json['threadMessageTime'] as int?,
    threadMessageToAccount: json['threadMessageToAccount'] as String,
  );
}

Map<String, dynamic> _$NIMMessageThreadOptionToJson(
        NIMMessageThreadOption instance) =>
    <String, dynamic>{
      'replyMessageFromAccount': instance.replyMessageFromAccount,
      'replyMessageToAccount': instance.replyMessageToAccount,
      'replyMessageTime': instance.replyMessageTime,
      'replyMessageIdServer': instance.replyMessageIdServer,
      'replyMessageIdClient': instance.replyMessageIdClient,
      'threadMessageFromAccount': instance.threadMessageFromAccount,
      'threadMessageToAccount': instance.threadMessageToAccount,
      'threadMessageTime': instance.threadMessageTime,
      'threadMessageIdServer': instance.threadMessageIdServer,
      'threadMessageIdClient': instance.threadMessageIdClient,
    };
